<?php

declare(strict_types=1);

/**
 * @author Holger Dehnhardt <holger@dehnhardt.org>
 *
 * Mail
 *
 * This code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License, version 3,
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

namespace OCA\Mail\Sieve;

use OCA\Mail\Contracts\ISieveParser;

class SieveParser implements ISieveParser {

	/** @var $splitQuotedStringByComma */
	private $splitQuotedStringByComma="/,(?=(?:[^\"\[\]]*[\"\[][^\"\]]*[\"\]])*[^\"\]]*$)/";

	/** @var $splitQuotedStringByBlank */
	private $splitQuotedStringByBlank="/ (?=(?:[^\"\[\]]*[\"\[][^\"\]]*[\"\]])*[^\"\]]*$)/";

	/** @var $installedExtensions */
	private $installedExtensions = [];

	/** @var $sieveStructure array */
	private $sieveStructure;

	/** @var $parsedTree */
	private $parsedTree = [];

	/** @var $ruleNumber */
	private $ruleNumber = 0;

	/** @var $headerRule */
	private $headerRule = [];

	/** @var $requirements */
	private $requirements = [];

	/** @var $generatorName */
	public const GENERATOR_NAME = "Nextcloud Mail";

	/** @var $origin */
	private $native = false;

	/**
	 *
	 * @param SieveStructure $sieveStructure
	 *
	 * @return array;
	 */
	public function __construct(SieveStructure $sieveStructure) {
		$this->sieveStructure = $sieveStructure;
	}

	/**
	 *
	 * @param array $sieveExtensions
	 *
	 * @return array;
	 */
	public function getSupportedSieveStructure(array $sieveExtensions) : array {
		$this->installedExtensions = $sieveExtensions;
		return $this->sieveStructure->getSupportedStructure($sieveExtensions);
	}

	/**
	 *
	 * @param string $sieveClientFactory
	 *
	 * @return array;
	 */
	public function parse(string $script) : array {
		$this->headerRule['scriptOrigin'] = 'unknown';
		$this->headerRule['type'] = 'header';
		$this->parseMultilineComments($script);
		array_splice($this->parsedTree, 0, 0, [$this->headerRule]);
		return $this->parsedTree;
	}

	private function parseMultilineComments(string $script) {
		//separate multiline comments from singleline comments and instructions
		$tokens = preg_split("/(\/\*[^*]*\*\/)/s", $script, -1, PREG_SPLIT_DELIM_CAPTURE);
		foreach ($tokens as $token) {
			$token = trim($token);
			if (stripos($token, "/*") === 0) {
				$this->parsedTree[] = ["type" => "comment", "value" => $token];
			} else {
				$this->parseRules($token);
			}
		}
	}

	private function guessSpecialMeanings($token) : bool {
		$i = preg_match("/#.*generated by ([^#]*)#/si", $token, $matches);
		$ret = false;
		if ($i > 0) {
			$this->headerRule['scriptOrigin']=trim($matches[1]);
			$this->native = ($this->headerRule['scriptOrigin'] === SELF::GENERATOR_NAME);
			$ret = true;
		} elseif (stripos($token, "RAINLOOP:SIEVE") !== false) {
			$this->headerRule['scriptOrigin']="Rainloop";
			$ret = true;
		}
		return $ret;
	}

	private function parseRules(string $script) {
		$tokencount=0;
		$rules=0;
		// For scripts with rule naming convention "# rule:[" which is used by several sieve clients
		$tokens = preg_split("/(# rule:[^\{]*\{(?:[^{}]++|(?R))*\})/", $script, -1, PREG_SPLIT_DELIM_CAPTURE);
		if (sizeof($tokens) > 1 && stripos($tokens[0], "# rule:[") === false) {
			$header = preg_split("/\r\n/", $tokens[0]);
		}
		// if no rule naming convention found, split by topmost 'if' statements:
		// Everything above the first if statement is some kind of header
		if (sizeof($tokens) === 1) {
			$tokens = preg_split("/(if[^\{]*\{(?:[^{}]++|(?R))*\})/", $script, -1, PREG_SPLIT_DELIM_CAPTURE);
			if (sizeof($tokens) > 0 && stripos($tokens[0], "if") === false) {
				// Split header by line
				$header = preg_split("/\r\n/", $tokens[0]);
			}
		}
		// If header consists of more than one line, remove the unsplit header
		// and replace with 'line by line' header
		if (sizeof($header) > 1) {
			unset($tokens[0]);
			$tokens = array_merge($header, $tokens);
		}
		// than iterate throug all tokens
		foreach ($tokens as $token) {
			$token = trim($token);
			if (stripos($token, "require") === 0) {
				// requires found, although useless for us,
				// because we have to recollect the requires when rules change
				$this->parsedTree[] = ["type" => "require", "value" => $token];
			} elseif (stripos($token, "# rule:[") === 0 || stripos($token, "if") === 0) {
				// we have found comments with rulenames or the start of a rule (if)
				$this->ruleNumber++;
				$this->parsedTree[]= $this->parseRule($token);
				;
			} elseif (stripos($token, "#") === 0) {
				// single line comment found
				// if we have found a hint for an originator if the
				// file, we will store it and will not store this token
				if (!$this->guessSpecialMeanings($token)) {
					// otherwise siply store the comment
					$this->parsedTree[] = ["type" => "comment", "value" => $token];
				}
			}
			$tokencount++;
		}
	}

	private function parseRule(string $rule) : array {
		// we will handle the rule here
		$level_1 = ["type" => "rule"];
		if ($this->native) {
			$level_1['comment'] = "";
		}
		$namefound = false;
		if (stripos($rule, "# rule:[") === 0) {
			// here we have a rule with naming convention
			// separate name from rule
			$i = preg_match("/[^\[]*\[([^\]]*)\](.*)/s", $rule, $matches);
			if ($i > 0) {
				// if we can identify a rulename -> store and remember it is the original name
				$level_1['name'] = $matches[1];
				$level_1['rule'] = $matches[2];
				$namefound = true;
				if (stripos($rule, "# comment:[")) {
					$i = preg_match("/# comment:[^\[]*\[([^\]]*)\](.*)/s", $rule, $matches);
					if ($i > 0) {
						$level_1['comment'] = $matches[1];
					}
				}
				$level_1['parsedrule'] = $this->parseRuleBody($matches[2]);
			} else {
				// for some reason we can not finde the name (fallback)
				// we assign a name pattern and make it read only
				// simply parse the rule
				$level_1['name'] = "Rule " . $this->ruleNumber;
				$level_1['rule'] = $rule;
				$level_1['parsedrule'] = $this->parseRuleBody($rule);
			}
		} else {
			// no naming convention found - simply parse the rule
			// we assign a name pattern and make it read only
			$level_1['name'] = "Rule " . $this->ruleNumber;
			$level_1['rule'] = $rule;
			$level_1['parsedrule'] = $this->parseRuleBody($rule);
		}
		$level_1['origname'] = $namefound;
		return $level_1;
	}

	private function parseRuleBody($ruleBody) : array {
		$level_2 = [];
		$ruleBody = trim($ruleBody);
		// search for everything between if/else/elsif and a closing bracket '}'
		// to find the conditions and actions
		$matched = preg_match_all("/((if|else|elsif)[^}]*})/m", $ruleBody, $matches);
		if ($matched > 0) {
			foreach ($matches[1] as $match) {
				$level_2 = $this->parseSingleRuleBody($match);
			}
		}
		return $level_2;
	}

	private function parseSingleRuleBody($ruleBody) : array {
		$level_3 = [];
		// search for everything between if/else/elsif and an opening bracket '{'
		// to find only the conditons
		$matched = preg_match_all("/((if|else|elsif)[^{]*)/m", $ruleBody, $matches);
		if ($matched > 0) {
			foreach ($matches[1] as $match) {
				$level_3["conditions"] = $this->parseCondition($match);
			}
		}
		// match anything after an openig bracket until the last semikolon
		// to find only the actions
		$matched = preg_match_all("/([^;{]*;)/", $ruleBody, $matches);
		if ($matched > 0) {
			foreach ($matches[1] as $match) {
				$level_3["actions"][] = $this->parseAction(trim($match, " ;,%*?\t\n\r\x0B()"));
			}
		}
		return $level_3;
	}

	private function parseCondition($condition) : array {
		$level_4 = [];
		$verbs = preg_split("/ +/", $condition, -1, PREG_SPLIT_DELIM_CAPTURE);
		$level_4['condition-verb'] = trim($verbs[0]," \t\n\r\0\x0B()");
		if (in_array(trim($verbs[1], " \t\n\r\0\x0B()"), $this->sieveStructure->sieveListOperators)) {
			$level_4['testlist']['sieveListOperator']=trim($verbs[1]," \t\n\r\0\x0B()");
			$matched=preg_match("/\(([^\)]*)\)/", $condition, $matches);
			if ($matched > 0) {
				$level_4['testlist']['tests'] = $this->parseConditionComparisonsList(trim($matches[1]));
			}
		} else {
			unset($verbs[0]);
			$level_4['testlist']['tests'][] = $this->parseConditionComparisons(trim(implode(" ", $verbs)));
		}
		return $level_4;
	}

	private function parseConditionComparisonsList($condition) : array {
		$level_5 = [];
		$conditions = preg_split($this->splitQuotedStringByComma, $condition);
		foreach ($conditions as $condition) {
			$level_5[] = $this->parseConditionComparisons(trim($condition));
		}
		return $level_5;
	}

	private function parseConditionComparisons($condition) : array {
		$level_6 = [];
		$tokens = preg_split($this->splitQuotedStringByBlank, $condition);
		for ($i = 0; $i < count($tokens); ++$i) {
			$token = $tokens[$i];
			if (array_key_exists($token, $this->sieveStructure->sieveTestSubjects)) {
				$level_6['testSubject'] = $token;
				$params = $this->sieveStructure->sieveTestSubjects[$token]->parameters;
				$conditionParameters = $this->parseConditionParameters($tokens, $params, $i);
				$level_6['parameters'] = $conditionParameters;
				continue;
			}
			if (in_array($token, $this->sieveStructure->sieveMatchTypes)) {
				$level_6['matchtype'] = $token;
				continue;
			}
			$level_6[] = $token;
		}
		return $level_6;
	}

	private function parseConditionParameters($tokens, $paramlist, &$offset) : array {
		$params = explode(' ', $paramlist);
		$level_6 = [];
		++$offset;

		for ($i = 0; $i < count($params); ++$i) {
			$param = $params[$i];
			if (stripos($param, "%?comparator") === 0) {
				// currently ignored
				continue;
			}

			if (stripos($tokens[$offset], "[") === 0) {
				$token_array = explode(' ', $tokens[$offset]);
				array_walk($token_array, [$this, "trimArray"]);
				$level_6[trim($param, " %*?\"")] = $token_array;
			} else {
				$level_6[trim($param, " %*?\"")][] = trim($tokens[$offset], " %*?\"");
			}
			++$offset;
		}
		return $level_6;
	}

	private function parseAction(string $actionString) {
		$level_4 = [];
		$offset = 0;
		$tokenArray = preg_split($this->splitQuotedStringByBlank, $actionString);
		array_walk($tokenArray,  [$this, "trimArray"]);
		$action = $tokenArray[0];
		$level_4['action'] = $action;
		$paramlist = $this->sieveStructure->sieveActions[$action]->parameters;
		if (sizeof($tokenArray)>1 && $paramlist !== "") {
			$level_4['parameters'] = $this->parseActionParameters($tokenArray, $paramlist, $offset);
		}
		return $level_4;
	}

	private function parseActionParameters($tokens, $paramlist, &$offset) : array {
		$params = explode(' ', $paramlist);
		$level_5 = [];
		++$offset;

		for ($i = 0; $i < count($params); ++$i) {
			$param = $params[$i];
			if (stripos($tokens[$offset], "[") === 0) {
				$token_array = explode(' ', $tokens[$offset]);
				array_walk($token_array, [$this, "trimArray"]);
				$level_5[trim($param, " %*?\"")] = $token_array;
			} else {
				$level_5[trim($param, " %*?\"")][] = $tokens[$offset];
			}
			++$offset;
		}
		return $level_5;
	}

	public function merge(array $scriptContent) {
		$script = "";
		foreach ($scriptContent as $contentItem) {
			switch ($contentItem['type']) {
				case 'header': $script .= $this->mergeHeader($contentItem) . "\r\n";
				break;
				case 'require': break;
				case 'comment': $script .= $this->mergeComment($contentItem) . "\r\n";
				break;
				case 'rule': $script .= $this->mergeRule($contentItem) . "\r\n";
				break;
				default: break;
			}
		}
		return $this->mergeRequire() . $script;
	}
	private function mergeRequire() {
		$require = "";
		if (sizeof($this->requirements) > 0) {
			$require .= "require [";
			$i = 0;
			foreach ($this->requirements as $requirement) {
				if ($i > 0) {
					$require .= ", ";
				}
				$require .= '"' . $requirement . '"';
			}
			$require .= "];\r\n";
		}
		return $require;
	}
	private function mergeHeader(array $token) {
		$header = "";
		if ($token['scriptOrigin'] !== 'unknown') {
			$header = "## Generated by " . $token['scriptOrigin'] . " ##";
		}
		return $header;
	}

	private function mergeComment(array $token) {
		$comment = $token['value'];
		return $comment;
	}

	private function mergeRule(array $token) {
		$rule = "";
		if ($token['name'] !== "" && $token['origname']) {
			$rule .= "# rule:[" . $token['name'] . "]\r\n";
		}
		$rule .= $this->mergeParsedRule($token['parsedrule']);
		return $rule;
	}

	private function mergeParsedRule(array $token) {
		$parsedRule = "";
		$parsedRule .= $this->mergeConditions($token['conditions']);
		$parsedRule .= $this->mergeActions($token['actions']);
		return $parsedRule;
	}

	private function mergeActions(array $token) {
		$actions = "{";
		foreach ($token as $action) {
			$actions .= "\r\n\t" . $this->mergeAction($action) . ";";
		}
		$actions .= "\r\n}";
		return $actions;
	}

	private function mergeAction(array $token) {
		$actionname = $token['action'];
		$action = $actionname . " ";
		$extension =$this->sieveStructure->sieveActions[$actionname]->extension;
		if ($extension !== '' && array_search($extension, $this->requirements) === false) {
			$this->requirements[] = $extension;
		}
		if ($token['parameters']) {
			$action .= $this->mergeActionParameters($actionname, $token['parameters']);
		}
		return $action;
	}

	private function mergeActionParameters(string $action, array $parameters) {
		$actionparameters = "";
		$expectedParameters = $this->sieveStructure->sieveActions[$action]->parameters;
		if (trim($expectedParameters) === "") {
			return $actionparameters;
		}
		$expectedParamArray=explode(" ", $expectedParameters);
		foreach ($expectedParamArray as $expectedParam) {
			$multiple = false;
			$optional = false;
			$expectedParam = substr($expectedParam, 1);
			if (stripos($expectedParam, '*') === 0) {
				$multiple = true;
				$expectedParam = substr($expectedParam, 1);
			}
			if (stripos($expectedParam, '?') === 0) {
				$optional = true;
				$expectedParam = substr($expectedParam, 1);
			}
			if ($parameters[$expectedParam]) {
				$values = array_filter($parameters[$expectedParam], [$this, "filterEmpty"]);
				if ($values) {
					if (!$multiple && sizeof($values) > 1) {
						$this->logger->error("To much values for parameter");
					} elseif (!$optional && sizeof($values) === 0) {
						$this->logger("Error");
					} else {
						$isString = $this->sieveStructure->parameterTypes[$expectedParam] === "String";
						$actionparameters .= $this->mergeParameterArray($values, $isString) . " ";
					}
				}
			}
		}
		return $actionparameters;
	}

	private function mergeConditions(array $token) {
		$conditions = $token['condition-verb'] . " ";
		$conditions .= $this->mergeTestList($token['testlist']);
		return $conditions;
	}

	private function mergeTestList(array $token) {
		$testlist = "";
		$testcount = sizeof($token['tests']);
		if ($testcount > 1 && $token['sieveListOperator']) {
			$testlist .= $token['sieveListOperator'] . " ";
		}
		if ($testcount > 1) {
			$testlist .= "(\r\n";
		}
		$testlist .= $this->mergeTests($token['tests']);
		if ($testcount > 1) {
			$testlist .= "\r\n)";
		}
		return $testlist;
	}

	private function mergeTests(array $token) {
		$tests = "";
		$i = 0;
		foreach ($token as $test) {
			if ($i > 0) {
				$tests .= ",\r\n";
			}
			$tests .= "\t" . $this->mergeTest($test);
			++$i;
		}
		return $tests;
	}

	private function mergeTest(array $test) {
		$testsubject = $test['testSubject'];
		$testval = $testsubject . " ";
		$extension =$this->sieveStructure->sieveTestSubjects[$testsubject]->extension;
		if ($extension !== '' && array_search($testsubject, $this->requirements) === false) {
			$this->requirements[] = $extension;
		}
		$testval .= $this->mergeTestParameters($test['testSubject'], $test['parameters']);
		return $testval;
	}

	private function mergeTestParameters(string $testsubject, array $parameters) {
		$testparameters = "";
		$expectedParameters = $this->sieveStructure->sieveTestSubjects[$testsubject]->parameters;
		$expectedParamArray=explode(" ", $expectedParameters);
		foreach ($expectedParamArray as $expectedParam) {
			$multiple = false;
			$optional = false;
			$expectedParam = substr($expectedParam, 1);
			if (stripos($expectedParam, '*') === 0) {
				$multiple = true;
				$expectedParam = substr($expectedParam, 1);
			}
			if (stripos($expectedParam, '?') === 0) {
				$optional = true;
				$expectedParam = substr($expectedParam, 1);
			}
			if ($parameters[$expectedParam]) {
				$values = array_filter($parameters[$expectedParam], [$this, "filterEmpty"]);
				if ($values) {
					if (!$multiple && sizeof($values) > 1) {
						$this->logger->error("To much values for parameter");
					} elseif (!$optional && sizeof($values) === 0) {
						$this->logger("Error");
					} else {
						$isString = $this->sieveStructure->parameterTypes[$expectedParam] === "String";
						$testparameters .= $this->mergeParameterArray($values, $isString) . " ";
					}
				}
			}
		}
		return $testparameters;
	}

	private function mergeParameterArray(array $values, bool $isString) {
		$params = "";
		$i = 0;
		if (sizeof($values) > 1) {
			$params .= "[";
		}
		foreach ($values as $value) {
			if ($i > 0) {
				$params .= ", ";
			}
			$params .= ($isString?'"':'') . $value . ($isString?'"':'');
			$i++;
		}
		if (sizeof($values) > 1) {
			$params .= "]";
		}
		return $params;
	}

	private function trimArray(&$item, $key) {
		$item = trim($item, " [],<>\"");
	}

	private function filterEmpty($var) {
		return $var !== "";
	}
}
